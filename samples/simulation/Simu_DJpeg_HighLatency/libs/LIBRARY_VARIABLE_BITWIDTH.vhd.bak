--####################################################################################################
--#
--#  ADDER COMPONENT WITH VARIABLE INPUTS AND OUTPUT BITWIDTH
--#  DEVELOPPED FOR THE GRAPHLAB TOOL BY BERTRAND LE GAL
--#	 IMS LABORATORY -  UMR-CNRS 5218
--#
--####################################################################################################
LIBRARY IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
library work;

ENTITY ADD_Dynamic IS
  GENERIC(
      	C_SIGNED          : NATURAL := 0;
      	INPUT_1_WIDTH     : NATURAL := 8;
      	INPUT_2_WIDTH     : NATURAL := 8;
      	OUTPUT_1_WIDTH    : NATURAL := 8
  	  );
  PORT ( 
		INPUT_1  :IN  STD_LOGIC_VECTOR(INPUT_1_WIDTH-1  DOWNTO 0);
		INPUT_2  :IN  STD_LOGIC_VECTOR(INPUT_2_WIDTH-1  DOWNTO 0);
		OUTPUT_1 :OUT STD_LOGIC_VECTOR(OUTPUT_1_WIDTH-1 DOWNTO 0)
		);
END;

ARCHITECTURE behavior OF ADD_Dynamic IS
BEGIN
	SIG:  IF C_SIGNED = 0 GENERATE
	PROCESS (INPUT_1, INPUT_2)
	BEGIN
		OUTPUT_1 <= STD_LOGIC_VECTOR( RESIZE( UNSIGNED( INPUT_1 ) + UNSIGNED( INPUT_2 ), OUTPUT_1_WIDTH) );
	END PROCESS;
	END GENERATE SIG;

	SIG2:  IF C_SIGNED = 1 GENERATE
	PROCESS (INPUT_1, INPUT_2)
	BEGIN
		OUTPUT_1 <= STD_LOGIC_VECTOR( RESIZE( SIGNED( INPUT_1 ) + SIGNED( INPUT_2 ), OUTPUT_1_WIDTH) );
	END PROCESS;
	END GENERATE SIG2;
END;


--####################################################################################################
--#
--#  SUBSTRACTOR COMPONENT WITH VARIABLE INPUTS AND OUTPUT BITWIDTH
--#  DEVELOPPED FOR THE GRAPHLAB TOOL BY BERTRAND LE GAL
--#	 IMS LABORATORY -  UMR-CNRS 5218
--#
--####################################################################################################
LIBRARY IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
library work;

ENTITY SUB_Dynamic IS
  GENERIC(
      	C_SIGNED          : NATURAL := 0;
      	INPUT_1_WIDTH     : NATURAL := 8;
      	INPUT_2_WIDTH     : NATURAL := 8;
      	OUTPUT_1_WIDTH    : NATURAL := 8
  	  );
  PORT ( 
		INPUT_1  :IN  STD_LOGIC_VECTOR(INPUT_1_WIDTH-1  DOWNTO 0);
		INPUT_2  :IN  STD_LOGIC_VECTOR(INPUT_2_WIDTH-1  DOWNTO 0);
		OUTPUT_1 :OUT STD_LOGIC_VECTOR(OUTPUT_1_WIDTH-1 DOWNTO 0)
		);
END;

ARCHITECTURE behavior OF SUB_Dynamic IS
BEGIN
	SIG:  IF C_SIGNED = 0 GENERATE
	PROCESS (INPUT_1, INPUT_2)
	BEGIN
		OUTPUT_1 <= STD_LOGIC_VECTOR( RESIZE( UNSIGNED( INPUT_1 ) - UNSIGNED( INPUT_2 ), OUTPUT_1_WIDTH) );
	END PROCESS;
	END GENERATE SIG;

	SIG:  IF C_SIGNED = 1 GENERATE
	PROCESS (INPUT_1, INPUT_2)
	BEGIN
		OUTPUT_1 <= STD_LOGIC_VECTOR( RESIZE( SIGNED( INPUT_1 ) - SIGNED( INPUT_2 ), OUTPUT_1_WIDTH) );
	END PROCESS;
	END GENERATE SIG;
END;



--####################################################################################################
--#
--#  MULTIPLIER COMPONENT WITH VARIABLE INPUTS AND OUTPUT BITWIDTH
--#  DEVELOPPED FOR THE GRAPHLAB TOOL BY BERTRAND LE GAL
--#	 IMS LABORATORY -  UMR-CNRS 5218
--#
--####################################################################################################
LIBRARY IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
library work;

ENTITY MUL_Dynamic IS
  GENERIC(
      	C_SIGNED          : NATURAL := 0;
      	INPUT_1_WIDTH     : NATURAL := 8;
      	INPUT_2_WIDTH     : NATURAL := 8;
      	OUTPUT_1_WIDTH    : NATURAL := 8
  	  );
  PORT ( 
		INPUT_1  :in  STD_LOGIC_VECTOR(INPUT_1_WIDTH-1  DOWNTO 0);
		INPUT_2  :in  STD_LOGIC_VECTOR(INPUT_2_WIDTH-1  DOWNTO 0);
		OUTPUT_1 :out STD_LOGIC_VECTOR(OUTPUT_1_WIDTH-1 DOWNTO 0)
		);
END;

ARCHITECTURE behavior OF MUL_Dynamic IS
BEGIN
	PROCESS (INPUT_1, INPUT_2)
		VARIABLE Stmp  : SIGNED  ((INPUT_1_WIDTH+INPUT_2_WIDTH)-1 DOWNTO 0);
		VARIABLE UStmp : UNSIGNED((INPUT_1_WIDTH+INPUT_2_WIDTH)-1 DOWNTO 0);
	begin
		IF C_SIGNED = 0 THEN
			UStmp    := RESIZE( UNSIGNED( INPUT_1 ) * UNSIGNED( INPUT_2 ), INPUT_1_WIDTH+INPUT_2_WIDTH);
			OUTPUT_1 <= STD_LOGIC_VECTOR( UStmp(OUTPUT_1_WIDTH-1 DOWNTO 0) );
		ELSE
			Stmp     := RESIZE( SIGNED( INPUT_1 ) * SIGNED( INPUT_2 ), INPUT_1_WIDTH+INPUT_2_WIDTH);
			OUTPUT_1 <= STD_LOGIC_VECTOR( Stmp(OUTPUT_1_WIDTH-1 DOWNTO 0) );
		END IF;
	END PROCESS;
END;



--####################################################################################################
--#
--#
--#
--#
--#
--####################################################################################################

--	MULTIPLIER COMPONENT WITH VARIABLE INPUTS AND OUTPUT BITWIDTH
--	DEVELOPPED FOR THE GRAPHLAB TOOL BY BERTRAND LE GAL
--	IMS LABORATORY -  UMR-CNRS 5218
LIBRARY IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
library work;

ENTITY DIVIDER_Dynamic IS
  GENERIC(
      	C_SIGNED          : NATURAL := 0;
      	INPUT_1_WIDTH     : NATURAL := 8;
      	INPUT_2_WIDTH     : NATURAL := 8;
      	OUTPUT_1_WIDTH    : NATURAL := 8
  	  );
  PORT ( 
		INPUT_1  :in  STD_LOGIC_VECTOR(INPUT_1_WIDTH-1  DOWNTO 0);
		INPUT_2  :in  STD_LOGIC_VECTOR(INPUT_2_WIDTH-1  DOWNTO 0);
		OUTPUT_1 :out STD_LOGIC_VECTOR(OUTPUT_1_WIDTH-1 DOWNTO 0)
		);
END;

ARCHITECTURE behavior OF DIVIDER_Dynamic IS
  -- MAXIMUM FUNCTION TO COMPUTE THE INTERNAL DATA SIZE
  FUNCTION maximum (left, right : NATURAL) return NATURAL IS
  BEGIN  -- function max
    IF LEFT > RIGHT THEN RETURN LEFT;
    ELSE RETURN RIGHT;
    END IF;
  END FUNCTION maximum;

BEGIN
	PROCESS (INPUT_1, INPUT_2)
		VARIABLE Stmp  : SIGNED  ((INPUT_1_WIDTH+INPUT_2_WIDTH)-1 DOWNTO 0);
		VARIABLE UStmp : UNSIGNED((INPUT_1_WIDTH+INPUT_2_WIDTH)-1 DOWNTO 0);
	begin
		IF C_SIGNED = 0 THEN
			UStmp    := RESIZE( UNSIGNED( INPUT_1 ) * UNSIGNED( INPUT_2 ), INPUT_1_WIDTH+INPUT_2_WIDTH);
			OUTPUT_1 <= STD_LOGIC_VECTOR( UStmp(OUTPUT_1_WIDTH-1 DOWNTO 0) );
		ELSE
			Stmp     := RESIZE( SIGNED( INPUT_1 ) * SIGNED( INPUT_2 ), INPUT_1_WIDTH+INPUT_2_WIDTH);
			OUTPUT_1 <= STD_LOGIC_VECTOR( Stmp(OUTPUT_1_WIDTH-1 DOWNTO 0) );
		END IF;
	END PROCESS;
END;


--####################################################################################################
--#
--#
--#
--#
--#
--####################################################################################################

--	SQUARE COMPONENT WITH VARIABLE INPUTS AND OUTPUT BITWIDTH
--	DEVELOPPED FOR THE GRAPHLAB TOOL BY BERTRAND LE GAL
--	IMS LABORATORY -  UMR-CNRS 5218
LIBRARY IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
library work;

ENTITY SQR_Dynamic IS
  GENERIC(
      	C_SIGNED          : NATURAL := 0;
      	INPUT_1_WIDTH     : NATURAL := 8;
      	OUTPUT_1_WIDTH    : NATURAL := 8
  	  );
  port (
		INPUT_1  :in  STD_LOGIC_VECTOR(INPUT_1_WIDTH-1  DOWNTO 0);
		OUTPUT_1 :out STD_LOGIC_VECTOR(OUTPUT_1_WIDTH-1 DOWNTO 0)
		);
END;

ARCHITECTURE behavior OF SQR_Dynamic IS
begin
	PROCESS (INPUT_1)
		VARIABLE Stmp  : SIGNED  ((INPUT_1_WIDTH+INPUT_1_WIDTH)-1 DOWNTO 0);
		VARIABLE UStmp : UNSIGNED((INPUT_1_WIDTH+INPUT_1_WIDTH)-1 DOWNTO 0);
	begin
		IF C_SIGNED = 0 THEN
			UStmp    := UNSIGNED( INPUT_1 ) * UNSIGNED( INPUT_1 );
			OUTPUT_1 <= STD_LOGIC_VECTOR( UStmp(OUTPUT_1_WIDTH-1 DOWNTO 0) );
		ELSE
			Stmp     := SIGNED( INPUT_1 ) * SIGNED( INPUT_1 );
			OUTPUT_1 <= STD_LOGIC_VECTOR( Stmp(OUTPUT_1_WIDTH-1 DOWNTO 0) );
		END IF;
	END PROCESS;
END;


--####################################################################################################
--#
--#
--#
--#
--#
--####################################################################################################

LIBRARY IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
library work;

ENTITY ABS_Dynamic IS
  GENERIC(
      	C_SIGNED          : NATURAL := 0;
      	INPUT_1_WIDTH     : NATURAL := 8;
      	OUTPUT_1_WIDTH    : NATURAL := 8
  	  );
  PORT ( 
		INPUT_1  :IN  STD_LOGIC_VECTOR(INPUT_1_WIDTH-1  DOWNTO 0);
		OUTPUT_1 :OUT STD_LOGIC_VECTOR(OUTPUT_1_WIDTH-1 DOWNTO 0)
		);
END;

ARCHITECTURE behavior OF ABS_Dynamic IS
  -- MAXIMUM FUNCTION TO COMPUTE THE INTERNAL DATA SIZE
  FUNCTION minimum (left, right : NATURAL) return NATURAL IS
  BEGIN  -- function max
    IF LEFT < RIGHT THEN RETURN LEFT;
    ELSE RETURN RIGHT;
    END IF;
  END FUNCTION minimum;

BEGIN
	PROCESS (INPUT_1)
		CONSTANT SIZE  : NATURAL := minimum(INPUT_1_WIDTH, OUTPUT_1_WIDTH);
		VARIABLE Stmp  : SIGNED  (SIZE-1 DOWNTO 0);
		VARIABLE UStmp : UNSIGNED(SIZE-1 DOWNTO 0);
	BEGIN
		IF C_SIGNED = 0 THEN
			UStmp    := RESIZE( UNSIGNED(INPUT_1), OUTPUT_1_WIDTH);
			OUTPUT_1 <= STD_LOGIC_VECTOR( UStmp(OUTPUT_1_WIDTH-1 DOWNTO 0) );
		ELSE
			Stmp     := RESIZE( abs(SIGNED( INPUT_1 )), OUTPUT_1_WIDTH);
			OUTPUT_1 <= STD_LOGIC_VECTOR( Stmp(OUTPUT_1_WIDTH-1 DOWNTO 0) );
		END IF;
	END PROCESS;
END;


--####################################################################################################
--#
--#
--#
--#
--#
--####################################################################################################

LIBRARY IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
library work;

ENTITY RSHIFT_Dynamic IS
  GENERIC(
      	C_SIGNED          : NATURAL := 0;
      	INPUT_1_WIDTH     : NATURAL := 8;
      	INPUT_2_WIDTH     : NATURAL := 8;
      	OUTPUT_1_WIDTH    : NATURAL := 8
  	  );
  PORT ( 
		INPUT_1  :in  STD_LOGIC_VECTOR(INPUT_1_WIDTH-1  DOWNTO 0);
		INPUT_2  :in  STD_LOGIC_VECTOR(INPUT_2_WIDTH-1  DOWNTO 0);
		OUTPUT_1 :out STD_LOGIC_VECTOR(OUTPUT_1_WIDTH-1 DOWNTO 0)
		);
END;

ARCHITECTURE behavior OF RSHIFT_Dynamic IS
  -- MAXIMUM FUNCTION TO COMPUTE THE INTERNAL DATA SIZE
  FUNCTION maximum (left, right : NATURAL) return NATURAL IS
  BEGIN  -- function max
    IF LEFT > RIGHT THEN RETURN LEFT;
    ELSE RETURN RIGHT;
    END IF;
  END FUNCTION maximum;

BEGIN
	PROCESS (INPUT_1, INPUT_2)
		VARIABLE Stmp  : SIGNED  ((INPUT_1_WIDTH+INPUT_2_WIDTH)-1 DOWNTO 0);
		VARIABLE UStmp : UNSIGNED((INPUT_1_WIDTH+INPUT_2_WIDTH)-1 DOWNTO 0);
	begin
		IF C_SIGNED = 0 THEN
			UStmp    := RESIZE( UNSIGNED( INPUT_1 ) * UNSIGNED( INPUT_2 ), INPUT_1_WIDTH+INPUT_2_WIDTH);
			OUTPUT_1 <= STD_LOGIC_VECTOR( UStmp(OUTPUT_1_WIDTH-1 DOWNTO 0) );
		ELSE
			Stmp     := RESIZE( SIGNED( INPUT_1 ) * SIGNED( INPUT_2 ), INPUT_1_WIDTH+INPUT_2_WIDTH);
			OUTPUT_1 <= STD_LOGIC_VECTOR( Stmp(OUTPUT_1_WIDTH-1 DOWNTO 0) );
		END IF;
	END PROCESS;
END;




--####################################################################################################
--#
--#
--#
--#
--#
--####################################################################################################

--	MULTIPLIER COMPONENT WITH VARIABLE INPUTS AND OUTPUT BITWIDTH
--	DEVELOPPED FOR THE GRAPHLAB TOOL BY BERTRAND LE GAL
--	IMS LABORATORY -  UMR-CNRS 5218
LIBRARY IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
library work;

ENTITY MAX_Dynamic IS
  GENERIC(
      	C_SIGNED          : NATURAL := 0;
      	INPUT_1_WIDTH     : NATURAL := 8;
      	INPUT_2_WIDTH     : NATURAL := 8;
      	OUTPUT_1_WIDTH    : NATURAL := 8
  	  );
  PORT ( 
		INPUT_1  :in  STD_LOGIC_VECTOR(INPUT_1_WIDTH-1  DOWNTO 0);
		INPUT_2  :in  STD_LOGIC_VECTOR(INPUT_2_WIDTH-1  DOWNTO 0);
		OUTPUT_1 :out STD_LOGIC_VECTOR(OUTPUT_1_WIDTH-1 DOWNTO 0)
		);
END;

ARCHITECTURE behavior OF MAX_Dynamic IS
  -- MAXIMUM FUNCTION TO COMPUTE THE INTERNAL DATA SIZE
  FUNCTION maximum (left, right : NATURAL) return NATURAL IS
  BEGIN  -- function max
    IF LEFT > RIGHT THEN RETURN LEFT;
    ELSE RETURN RIGHT;
    END IF;
  END FUNCTION maximum;

BEGIN
	USIG: IF C_SIGNED = 0 GENERATE
	PROCESS (INPUT_1, INPUT_2)
	BEGIN
		-- GESTION DU COMPORTEMENT EN MODE NON SIGNE
		IF( UNSIGNED(INPUT_1) > UNSIGNED(INPUT_2) ) THEN
			OUTPUT_1 <= STD_LOGIC_VECTOR( RESIZE(UNSIGNED(INPUT_1), OUTPUT_1_WIDTH) );
		ELSE
			OUTPUT_1 <= STD_LOGIC_VECTOR( RESIZE(UNSIGNED(INPUT_2), OUTPUT_1_WIDTH) );
		END IF;
	END PROCESS;
	END GENERATE USIG;

	SIG:  IF C_SIGNED = 1 GENERATE
	PROCESS (INPUT_1, INPUT_2)
	BEGIN
		-- GESTION DU COMPORTEMENT EN MODE SIGNE
			IF( SIGNED(INPUT_1) > SIGNED(INPUT_2) ) THEN
				OUTPUT_1 <= STD_LOGIC_VECTOR( RESIZE(SIGNED(INPUT_1), OUTPUT_1_WIDTH) );
			ELSE
				OUTPUT_1 <= STD_LOGIC_VECTOR( RESIZE(SIGNED(INPUT_2), OUTPUT_1_WIDTH) );
			END IF;
	END PROCESS;
	END GENERATE SIG;
END;


--####################################################################################################
--#
--#
--#
--#
--#
--####################################################################################################

--	MULTIPLIER COMPONENT WITH VARIABLE INPUTS AND OUTPUT BITWIDTH
--	DEVELOPPED FOR THE GRAPHLAB TOOL BY BERTRAND LE GAL
--	IMS LABORATORY -  UMR-CNRS 5218
LIBRARY IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
library work;

ENTITY MIN_Dynamic IS
  GENERIC(
      	C_SIGNED          : NATURAL := 0;
      	INPUT_1_WIDTH     : NATURAL := 8;
      	INPUT_2_WIDTH     : NATURAL := 8;
      	OUTPUT_1_WIDTH    : NATURAL := 8
  	  );
  PORT ( 
		INPUT_1  :in  STD_LOGIC_VECTOR(INPUT_1_WIDTH-1  DOWNTO 0);
		INPUT_2  :in  STD_LOGIC_VECTOR(INPUT_2_WIDTH-1  DOWNTO 0);
		OUTPUT_1 :out STD_LOGIC_VECTOR(OUTPUT_1_WIDTH-1 DOWNTO 0)
		);
END;

ARCHITECTURE behavior OF MIN_Dynamic IS
BEGIN
	USIG: IF C_SIGNED = 0 GENERATE
	PROCESS (INPUT_1, INPUT_2)
	BEGIN
		IF( UNSIGNED(INPUT_1) < UNSIGNED(INPUT_2) ) THEN
			OUTPUT_1 <= STD_LOGIC_VECTOR( RESIZE(UNSIGNED(INPUT_1), OUTPUT_1_WIDTH) );
		ELSE
			OUTPUT_1 <= STD_LOGIC_VECTOR( RESIZE(UNSIGNED(INPUT_2), OUTPUT_1_WIDTH) );
		END IF;
	END PROCESS;
	END GENERATE USIG;

	SIG:  IF C_SIGNED = 1 GENERATE
	PROCESS (INPUT_1, INPUT_2)
	BEGIN
		IF( SIGNED(INPUT_1) < SIGNED(INPUT_2) ) THEN
			OUTPUT_1 <= STD_LOGIC_VECTOR( RESIZE(SIGNED(INPUT_1), OUTPUT_1_WIDTH) );
		ELSE
			OUTPUT_1 <= STD_LOGIC_VECTOR( RESIZE(SIGNED(INPUT_2), OUTPUT_1_WIDTH) );
		END IF;
	END PROCESS;
	END GENERATE SIG;
END;

